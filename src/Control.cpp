/**
 * MIT License
 *
 * Copyright (c) 2018 Venkatraman Narayanan, Amrish Baskaran
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 *
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 *
 *  @file    Control.h
 *  @Author  Venkatraman Narayanan (vijay4313)
 *  @Author Amrish Baskaran (amrish1222)
 *  @copyright  MIT
 *  @brief  Control Source file
 */

#include <ros/ros.h>
#include "../include/Control.h"
#include "geometry_msgs/Twist.h"
#include "nav_msgs/Odometry.h"
#include <math.h>


Control::Control() {
  pathIndex = 0;
  subscribeDelay = 5;  // millisecond
  presentPosition.x = 0;
  presentPosition.y = 0;
  presentPosition.z = 0;

}

Control::~Control() {
  // TODO Auto-generated destructor stub
}

/**
  * @brief Updates the Path variable
  * @param  path the path vector generated by
  *         PathPlanning routine
  * @return none
  */

// std::vector<PathPlanning::point3d> path
void Control::setPathPts() {
  std::vector<PathPlanning::point3d> hardCodedPath;
  PathPlanning::point3d tempPoint;
  // hardCodedPath.push_back(tempPoint);
  tempPoint.z = 5;
  hardCodedPath.push_back(tempPoint);
  tempPoint.x = 10;
  hardCodedPath.push_back(tempPoint);
  tempPoint.y = 10;
  hardCodedPath.push_back(tempPoint);
  tempPoint.x = 0;
  hardCodedPath.push_back(tempPoint);
  tempPoint.y = 0;
  hardCodedPath.push_back(tempPoint);
  tempPoint.z = 0;
  hardCodedPath.push_back(tempPoint);
  Control::traversePath = hardCodedPath;
}

/**
  * @brief Generates the velocity and pose for
  * publishing to the required topic
  * @param  none
  * @return none
  */
geometry_msgs::Twist Control::getVelocityPose() {
  geometry_msgs::Twist newVelocity;
  int Pathsize = static_cast<int>(Control::traversePath.size());
  ROS_INFO_STREAM("PathSize="<<Pathsize);
  if (Control::pathIndex < Pathsize) {
    ROS_INFO_STREAM(
        "presentPosition=" << Control::presentPosition.x << "," << Control::presentPosition.y << "," << Control::presentPosition.z);
    ROS_INFO_STREAM(
        "New_pos="<<Control::traversePath[Control::pathIndex].x<< "," << Control::traversePath[Control::pathIndex].y << "," << Control::traversePath[Control::pathIndex].z);
    double zDiff = Control::traversePath[Control::pathIndex].z
        - Control::presentPosition.z;
    zDiff = (int) (zDiff * 1000.0) / 1000.0;
    ROS_INFO_STREAM("zDiff=" << zDiff);
    double xDiff = Control::traversePath[Control::pathIndex].x
        - Control::presentPosition.x;
    xDiff = (int) (xDiff * 1000.0) / 1000.0;
    ROS_INFO_STREAM("xDiff=" << xDiff);
    double yDiff = Control::traversePath[Control::pathIndex].y
        - Control::presentPosition.y;
    yDiff = (int) (yDiff * 1000.0) / 1000.0;
    ROS_INFO_STREAM("yDiff=" << yDiff);
    if (fabs(zDiff) > 0.2) {
      int signz = 1;
      ROS_INFO_STREAM("zDiff Loop");
      if (fabs(zDiff / Control::subscribeDelay) > 3) {
        // max limit of vel = 3
        if (zDiff < 0) {
          signz = -1;
        }
        zDiff = 3 * Control::subscribeDelay * signz;
      }
      newVelocity.linear.x = 0;
      newVelocity.linear.y = 0;
      newVelocity.linear.z = (zDiff * 5 / Control::subscribeDelay)
          + 0.2 * signz;
      //ROS_INFO_STREAM(newVelocity.linear.z);
    } else if (fabs(xDiff) > 0.5 || fabs(yDiff) > 0.5) {
      ROS_INFO_STREAM("x,yDiff Loop");
      int signx = 1;
      int signy = 1;
      if (fabs(xDiff / Control::subscribeDelay) > 3) {
        // max limit of vel = 3
        if (xDiff < 0) {
          signx = -1;
        }
        xDiff = 3 * Control::subscribeDelay * signx;
      }
      if (fabs(yDiff / Control::subscribeDelay) > 3) {
        // max limit of vel = 3
        if (yDiff < 0) {
          signy = -1;
        }
        yDiff = 3 * Control::subscribeDelay * signy;
      }
      newVelocity.linear.x = (xDiff * 5 / Control::subscribeDelay)
          + 0.2 * signx;
      newVelocity.linear.y = (yDiff * 5 / Control::subscribeDelay)
          + 0.2 * signy;
      newVelocity.linear.z = 0;
    } else {
      newVelocity.linear.x = 0;
      newVelocity.linear.y = 0;
      newVelocity.linear.z = 0;
      // if no difference then increment to next point
      Control::pathIndex += 1;
    }
  } else {
    newVelocity.linear.x = 0;
    newVelocity.linear.y = 0;
    newVelocity.linear.z = 0;
    ROS_INFO("No new points");
  }
  // return the required Twist velocity
  return newVelocity;
}


void Control::setPresentPosition(PathPlanning::point3d position) {
  Control::presentPosition = position;
}
void Control::setPresentOrientation(PathPlanning::point3d orientation) {
  Control::presentOrientation = orientation;
}

void Control::navMessageReceived(const nav_msgs::Odometry::ConstPtr &msg) {
  PathPlanning::point3d readPosition;
  readPosition.x = msg->pose.pose.position.x;
  readPosition.y = msg->pose.pose.position.y;
  readPosition.z = msg->pose.pose.position.z;
  Control::setPresentPosition(readPosition);

  // todo need to convert quaternion to orientation
  PathPlanning::point3d readOrientation;

  // *****************
  Control::setPresentOrientation(readOrientation);
}
